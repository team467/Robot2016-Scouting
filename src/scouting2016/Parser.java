package scouting2016;

import java.awt.Dimension;
import java.awt.Toolkit;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumnModel;
import scouting2016.MainFrame.QueryContainer;



/**
 *
 * @author Adam Frick
 */
public class Parser 
{
    
    // takes match sheet filename and returns its info
    String[] splitString(String split)  
    {
        String[] splittedString = null;
        int tempInt = 0;
        splittedString = split.split("-");
        // iterates through each piece of file name (separated by -)
        for (String string : splittedString)
            {
                if (string.endsWith(".txt"))
                {
                    splittedString[tempInt] = string.split(".txt")[0];
                } 
                tempInt++;
            }
        return splittedString;
    }
            
    // sets table of data for each team from the match sheets
    void tableParse(javax.swing.JTable introTable, boolean searchQuery, 
            QueryContainer queryContainer) throws FileNotFoundException
    {   
        // # of sheets for each team (value changed in each loop)
        int totalSheets = 0;
        
        // in case of a bad file/filename it breaks before trying to add row
        boolean abort = false;

        // vars used to fetch data from each sheet 
        // [query - keyword; queryResult - data from keyword]
        String queryResult = null;
        String query = "";
        
        // arrays containing all parsed data from sheets
        List<String> teamList = new LinkedList<>();
        List<List<String>> scoreList = new LinkedList<>();
        List<List<String>> wonList = new LinkedList<>();
        List<List<String>> queryList = new LinkedList<>();
        
        // for accessing table interfaces
        DefaultTableModel introModel = (DefaultTableModel) introTable.getModel();
        
        final int introRowCount = introTable.getRowCount(); // gets # of rows to remove in table
        for (int i = 0; i < introRowCount; ++i)
        {
            ((DefaultTableModel) introTable.getModel()).removeRow(0);           
        }
        
        // array of every single file in relative /Sheets folder [case-sensitive]
        File[] files = new File("./Sheets").listFiles();
        
        // uses file name to confirm sheet was generated by program
        String[] splittedString = null;
        
        
        if (files != null)
        {
            // returns string array of all teams
            teamList = teamListGen(files);
        
            // goes through each individual team number
            for (int i = 0; i < teamList.size(); ++i)
            {
                // adds dimensions to 2D ArrayList
                scoreList.add(new ArrayList());
                wonList.add(new ArrayList());
                queryList.add(new ArrayList());
                
                totalSheets = 0;
                
                // goes indisciminately through all files (inefficient)
                for (File file:files)
                {
                    // contains string of file name
                    String wholeString = "";
                    
                    if (!file.isDirectory()) {
                        
                        // gets name of file
                        Scanner scanner = new Scanner(file);
                        wholeString = file.getName();
                        
                        if (wholeString.startsWith("ScoutSheet")) 
                        {
                            splittedString = splitString(wholeString);
                            
                            if (splittedString[1].equals(teamList.get(i))
                                && (!wholeString.contains("--")))
                            {
                                // from this point, file is observed to be for program
                                totalSheets++;
                                
                                // gets results of sheet from named query
                                query = "Score: ";
                                queryResult = queryFind(file, null, query, false);
                                scoreList.get(i).add(queryResult);
                                query = "Won: ";
                                queryResult = queryFind(file, null, query, false);
                                wonList.get(i).add(queryResult);
                                
                                // only if user seraches for their own query
                                if (searchQuery) {
                                    
                                    // searches for query
                                    query = queryContainer.queryHeader + ": ";
                                    queryResult = queryFind(file, null, query, false);
                                    
                                    // 2 is index for query string
                                    if (queryContainer.queryIndex != 2)
                                    {
                                        if (queryContainer.queryString.equals(queryResult))
                                            queryList.get(i).add(queryResult);
                                    }
                                    // if index otherwise, can change data type to integer
                                    
                                    // this is so that integer sorting is by magnitude, not
                                    //  by char representation of numbers 
                                    else
                                        {
                                            if ((Integer.valueOf(queryContainer.queryString) <= 
                                                    Integer.valueOf(queryResult) )
                                                    && 
                                                    (Integer.valueOf(queryContainer.queryStringAlt) >=
                                                    Integer.valueOf(queryResult)) )
                                                queryList.get(i).add(queryResult);
                                        }
                                }
                        
                            // queryResult OUTSIDE this loop will get the last file info
                            }
                    }
                    }
                        
                    // in file name generation, two dashes should never be together
                    
                    // a stricter way to check for malformed file name would be beneficial
                    else if (wholeString.contains("--"))
                    {
                        JOptionPane.showMessageDialog(null,
                        "File name: \"" + file.getName() + "\" is malformed."
                                + "\nAborting sheet collection.",
                        "Error",
                        JOptionPane.ERROR_MESSAGE);
                        abort = true;
                    }
                    
                }
                
                // aborts for loop
                if (abort == true)
                    break;
                
                // adds data found to 2D ArrayLists
                scoreList = colQueryParser(scoreList, i, 0);
                scoreList = colQueryParser(scoreList, i, 1);
                wonList = colQueryParser(wonList, i , 2);
           
                // data model depends on whether or not user used search function
                if (!searchQuery) 
                {
                    introModel.addRow(new Object[]{Integer.valueOf(teamList.get(i)), 
                    /*Max Score*/    Integer.valueOf(scoreList.get(i).get(scoreList.get(i).size()-2)),
                    /*Mean Score*/   Integer.valueOf(scoreList.get(i).get(scoreList.get(i).size()-1)),
                    /*Win Rate*/     Integer.valueOf(wonList.get(i).get(wonList.get(i).size()-1))});
                }
                else
                {   
                    // finds # of occurances of search
                    queryList = colQueryParser(queryList, i, 3);
                    
                    // adds divisor (total sheets) for a specific team from query
                    queryList.get(i).add(queryList.get(i).size(), 
                            queryList.get(i).get(queryList.get(i).size()-1).concat(String.valueOf(totalSheets)));
                    
                    introModel.addRow(new Object[]{Integer.valueOf(teamList.get(i)), 
                    /*Max Score*/    Integer.valueOf(scoreList.get(i).get(scoreList.get(i).size()-2)),
                    /*Mean Score*/   Integer.valueOf(scoreList.get(i).get(scoreList.get(i).size()-1)),
                    /*Win Rate*/     Integer.valueOf(wonList.get(i).get(wonList.get(i).size()-1)),
                    /*Query*/        queryList.get(i).get(queryList.get(i).size()-1)
                    });
                }
                
            }
                     
        }
       
        else
        {
            System.out.println("No files in directory");
        }         
    }
    
    // used for obtaining in data found from all match sheets of given team
    List<List<String>> colQueryParser(List<List<String>> colQuerier, int i, int id) {
        
        // value to be sequentially added to data cells of row i
        int colQueryValue = 0;
        
        // index of sheets in focus
        int colQueryIndex;
        
        // # of sheets for needed cell (row i, column of id)
        int colQuerySize = colQuerier.get(i).size();
        
        /*
        id 0: max score
        id 1: average score
        id 2: win rate
        id 3: query (search)
         */
        
        // iterates through queries of each sheet of given team of row i
        for (colQueryIndex = 0; colQueryIndex < colQuerySize; colQueryIndex++)
                {
                    switch (id) {
                        
                        case 0: // checks each score if one is greater than previous (default at 0)
                            if (Integer.parseInt(colQuerier.get(i).get(colQueryIndex)) > colQueryValue)
                            {
                                colQueryValue = Integer.parseInt(colQuerier.get(i).get(colQueryIndex));
                            }
                        break;
                        
                        case 1: // sums all scores
                            if (colQueryIndex + 1 != colQuerySize)
                                colQueryValue += Integer.parseInt(colQuerier.get(i).get(colQueryIndex));
                        break;
                        
                        case 2: // checks if sheet was a winner
                            if (colQuerier.get(i).get(colQueryIndex).equals("true"))
                            {
                                colQueryValue++;
                            }
                        break;
                        
                        case 3: // checks if search matched query
                            if (!(colQuerier.get(i).get(colQueryIndex).equals("String not found.")))
                            {
                                colQueryValue++;
                            }
                        break;
                        
                        default:
                            System.out.println("ID Error");       
                    }   
                        
                }
        
        switch (id) {
            case 0:  // max score of team
                colQuerier.get(i).add(String.valueOf(colQueryValue));
            break;
            
            case 1:  // divides sum of score by number of sheets to get mean score of team
                if (colQueryIndex == 0)
                    colQueryIndex++;
                colQueryValue /= colQueryIndex-1;
                colQuerier.get(i).add(String.valueOf(colQueryValue));
            break;
            
            case 2:  // divides sum of wins to total sheets to get win rate for the team
                if (colQueryIndex == 0)
                    colQueryIndex++;
                
                colQueryValue *= 100;
                colQueryValue /= (colQueryIndex);
                colQuerier.get(i).add(String.valueOf(colQueryValue));
            break;
                
            case 3:  // only adds # of sheets with given search as total sheets are given later
                colQuerier.get(i).add(String.valueOf(colQueryValue) + "/");
            break;
            
            default:
                System.out.println("ID Error");
                
        }
        
        return colQuerier;
    }
    
    // uses match sheet template to fill out combo box of the info filled out in them
    void comboSet (javax.swing.JComboBox queryCombo) throws FileNotFoundException {
    
        Template template = new Template();
        Scanner scanner = new Scanner(template.templateStr);
        String fileLine;
        String[] splitFileLine;
        while (scanner.hasNextLine()) 
        {
            fileLine = scanner.nextLine();
            if (fileLine.contains(":")) 
            {
                splitFileLine = fileLine.split(":");
                if (splitFileLine[0].contains("\t")) 
                {
                    splitFileLine = splitFileLine[0].split("\t");
                    queryCombo.addItem(splitFileLine[1]);
                }
                else 
                {
                    queryCombo.addItem(splitFileLine[0]);
                }                         
            }
        }
   
   }
     
    // sets table of data for a specific team selected in main table
    void teamTableParse(int introTeam, javax.swing.JTable teamTable, boolean columnChange) 
           throws FileNotFoundException, IOException
    {
       
        File[] files = new File("./Sheets").listFiles();
        String queryResult;
        ArrayList<String> teamQueries = new ArrayList<>();
        ArrayList<String> teamInfo = new ArrayList<>();
        DefaultTableModel teamModel = (DefaultTableModel) teamTable.getModel();
        TableColumnModel teamColumnModel = teamTable.getColumnModel();

        teamModel.setRowCount(0);
        
        for (int i = 0; i < teamColumnModel.getColumnCount(); i++)
            {
                
                teamQueries.add(teamColumnModel.getColumn(i).getHeaderValue().toString());
                teamQueries.set(i, teamQueries.get(i) + ": ");
            }
        
        if (files != null)
        {
        
            
            
         // goes through all files and searches for scout sheets for specific team
            for (File file:files) 
            {  
                
                    String wholeString = file.getName();
                    
                    if (!file.isDirectory() && wholeString.startsWith("ScoutSheet-" +
                            String.valueOf(introTeam)))
                    {   
                        for (String teamQuery: teamQueries)
                        {
                            queryResult = queryFind(file, null, teamQuery, false);
                            teamInfo.add(queryResult);
                        }
                        
                        String[] teamInfoArr = new String[teamInfo.size()];
                        teamInfoArr = teamInfo.toArray(teamInfoArr);    
                      
                        teamModel.addRow((Object[])teamInfoArr);
                        
                        
                        // makes sheets correctly sortable by numbers
                        // by converting the strings to integers
                        for (int i = 0; i < teamInfo.size(); i++) {
                            
                            try 
                            {
                                teamModel.setValueAt(Integer.valueOf(teamInfoArr[i]),
                                        teamModel.getRowCount()-1, i);
                            }
                          
                            catch (Exception e) 
                            {
                                // catches if not an integer (supposed to happen for non-integers)
                            }
                        }
                        
                        teamInfo.clear();
                    }    
            }
        }
   }
    
         
        
    // generates list of teams from all match sheet files
    private ArrayList teamListGen(File[] files )
    {           
        //used to check each team #
        boolean isSame = false;
        String[] splittedString;
        
        ArrayList<String> teamList = new ArrayList<>();
        
        for (File file:files)
            {
                String wholeString = file.getName();
                if (!file.isDirectory() && wholeString.startsWith("ScoutSheet")
                    && (!wholeString.contains("--"))) 
                {
                    splittedString = splitString(wholeString);
                    
                    // this always happens first
                    if (teamList.isEmpty())
                    {
                        teamList.add(splittedString[1]);
                    }
                    else
                    {   // iterates through each team #, checks equality, until no more sheets
                        for (int i = 0; i < teamList.size(); i++)
                        {
                            if (teamList.get(i).equals(splittedString[1])) 
                            {   // if file has a team name already listed, it moves to next file
                                isSame = true;
                                break;
                            } 
                        }   // then it is judgement time, whether it can be added to ArrayList
                        if (isSame == false)
                        {
                            teamList.add(splittedString[1]);
                        }
                        else 
                        {
                            isSame = false;
                        }
                    }
                        
                }     
            }
        return teamList;
    }
    
    // searches for data needed in file
    
    // typeFind is true if function is used for getting data type of sheet data from template
    // typeFind is false if function is used for getting value of sheet data from match sheet
    String queryFind(File file, String templateString, String query, 
              boolean typeFind) throws FileNotFoundException
    {
        Scanner scanner;
        if (typeFind == false)
            scanner = new Scanner(file);
        else
            scanner = new Scanner(templateString);
        
        while (scanner.hasNextLine()) 
        {
            String fileLine = scanner.nextLine();
            
            // parsing method depends on typeFind
            if(fileLine.contains(query)) 
                try 
                {
                    if (typeFind == false)
                        return fileLine.split(query)[1];
                    else
                        return fileLine.split(query + ":")[1];        
                }
                catch (Exception e) 
                {
                    return "Nothing to return";
                }
        }
        return "String not found.";
    }
     

    void windowSet(JFrame frame) 
    {
 
        // sets window to center of screen
        Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();
        
        // alerts user if screen resolution is below 1024x768 
        if (dim.width < 1024 || dim.height < 768)
        {
            JOptionPane.showMessageDialog(null,
            "Your screen resolution is not supported. Some "
                    + "elements may not appear or may appear incorrectly.",
            "Error",
            JOptionPane.ERROR_MESSAGE);
        }
        
        // sets JFrame into center of screen
        frame.setLocation(
                (int)dim.getWidth()/2 - frame.getSize().width/2, 
                (int)dim.getHeight()/2 - frame.getSize().height/2);
    }
    
}
